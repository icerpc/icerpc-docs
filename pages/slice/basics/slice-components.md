---
title: Slice components
description: A short description of each Slice component.
---

Slice is made of several related components:

- the Slice language\
The Slice language is a computer language designed for RPCs, but not tied to a specific RPC framework. You use Slice to
specify RPCs and types used by these RPCs. It's a simple language without any execution logic: no if, no while, no
print. While you specify your RPCs in Slice, you implement the actual "business logic" using the programming language of
your choice (C#, Rust, Python...). The Slice language is an [Interface Definition Language][idl] or IDL.

- the Slice encoding\
The Slice encoding specifies how Slice language constructs such as `string`, `int32`, `float64`, `struct` are encoded
into streams of bytes. The Slice encoding is a simple, compact, binary serialization format. Most Slice users don't need
to know the details of this encoding.

Then, for each programming language that Slice supports (currently C#, and soon Rust, Python and more), Slice provides:

- a Slice language mapping\
A language mapping is a set of rules that specifies how Slice language constructs are represented in that language.
For instance, a Slice `struct` is mapped to a `struct` in C#. The C# language mapping specifies the name of this struct,
its fields, its constructors etc.

- a Slice compiler\
A language mapping is implemented by a tool—the Slice compiler—that verifies your Slice syntax and generates code from
your Slice definitions to a "mapped" programming language. In C#, the Slice compiler for C#, `slicec-cs`, compiles Slice
files into C# files. When a Slice file defines a (Slice) struct, the corresponding C# file contains the mapped C#
struct.

- a Slice library\
The code generated by the Slice compiler relies on a Slice library in the target programming language. For example, the
code generated by the Slice compiler for C# relies on [SliceEncoder] and [SliceDecoder], two C# structs defined in
namespace [ZeroC.Slice][slice-namespace] that can encode resp. decode a variety of types to or from byte buffers. These structs are
provided by the [ZeroC.Slice] assembly and referenced by the code generated by the Slice compiler.

And lastly, a RPC framework that supports Slice adds:

- a language mapping for Slice interfaces and operations\
The RPC framework defines how Slice interfaces and operations are mapped in the target programming language. For
example, the IceRPC + Slice integration for C# maps each Slice interface to two C# interfaces and one C# struct.

- an augmented Slice compiler\
The RPC framework includes an augmented Slice compiler than generates code for Slice interfaces and operations.

- a library\
The code generated by the augmented Slice compiler uses both the Slice library, the RPC framework, and an additional
library that assists this integration. For example, the IceRPC + Slice integration in C# relies on the [IceRpc.Slice]
assembly.

All these Slice components work together to help you make RPCs without having to worry about encoding intricacies. With
IceRPC + Slice, your primary responsibility is to use the same Slice definitions in your client and server applications;
the code generated by the Slice compiler encodes and decodes your arguments and return values and exposes a high-level
easy-to-use typed API.

[idl]: https://en.wikipedia.org/wiki/Interface_description_language

[ZeroC.Slice]: https://www.nuget.org/packages/ZeroC.Slice
[IceRpc.Slice]: https://www.nuget.org/packages/IceRpc.Slice

[slice-namespace]: csharp:ZeroC.Slice
[SliceDecoder]: csharp:ZeroC.Slice.SliceDecoder
[SliceEncoder]: csharp:ZeroC.Slice.SliceEncoder
