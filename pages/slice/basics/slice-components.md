---
title: Slice components
description: A short description of each Slice component.
---

Slice is made of several related components:

- the Slice language\
The Slice language is a computer language designed for RPCs, but not tied to a specific RPC framework. You use Slice to
specify RPCs and types used by these RPCs. It's a simple language without any execution logic: no if, no while, no
print. While you specify your RPCs in Slice, you implement the actual "business logic" using the programming language of
your choice (C#, Rust, Python...). The Slice language is an [Interface Definition Language][idl] or IDL.

- the Slice encoding\
The Slice encoding specifies how Slice language constructs such as `string`, `int32`, `float64`, `struct` encoded into
streams of bytes. The Slice encoding is a simple, compact, binary serialization format. Most Slice users don't need to
know the details of this encoding.

Then, for each programming language that Slice supports (currently C#, and soon Rust, Python and more), Slice provides:

- a Slice language mapping\
A language mapping is a set of rules that specifies how Slice language constructs are represented in that language.
For instance, a Slice `struct` is mapped to a `struct` in C#. The C# language mapping specifies the name of this struct,
its fields, its constructors etc.

- a Slice compiler\
A language mapping is implemented by a tool—the Slice compiler—that verifies your Slice syntax and generates code from
your Slice definitions to a "mapped" programming language. In C#, the Slice compiler for C#, `slicec-cs`, compiles Slice
files into C# files. When a Slice file defines a (Slice) struct, the corresponding C# file contains the mapped C#
struct.

- Slice library code\
The code generated by the Slice compiler relies on Slice helper code in the target language. For example, the
code generated by the Slice compiler for C# relies on [`SliceEncoder`][slice-encoder] and
[`SliceDecoder`][slice-decoder], two C# structs defined in namespace [`ZeroC.Slice`][namespace] that can encode resp.
decode a variety of types to or from byte buffers. These structs are included in the `ZeroC.Slice` assembly and
referenced by the code generated by the Slice compiler.

And lastly, a RPC framework that supports Slice adds:

- a language mapping for Slice interfaces and operations\
The RPC framework defines how Slice interfaces and operations are represented ("mapped") in the target programming
language. For example, the Slice integration provided by IceRPC for C# maps each Slice interface to two C# interfaces
and one C# struct.

- an augmented Slice compiler\
The RPC framework includes an augmented Slice compiler than implements Slice interfaces using this RPC framework.

- library code\
The code generated by the augmented Slice compiler uses both the Slice library code, the RPC framework, and additional
helper code that assists this integration. In C#, this library code is provided by the `IceRpC.Slice` assembly.

All these Slice components work together to help you make RPCs without having to worry about encoding intricacies. With
IceRPC + Slice, your primary responsibility is to use the same Slice definitions in your client and server applications;
the code generated by the Slice compiler implements the Slice encoding and exposes a high-level easy-to-use typed API.

[idl]: https://en.wikipedia.org/wiki/Interface_description_language
[namespace]: csharp:ZeroC.Slice
[slice-decoder]: csharp:ZeroC.Slice.SliceDecoder
[slice-encoder]: csharp:ZeroC.Slice.SliceEncoder
