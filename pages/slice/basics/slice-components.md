---
title: Slice components
description: A short description of each Slice component.
---

Slice is made of several related components:

- the Slice language\
The Slice language is a computer language designed for RPCs, but not tied to a specific RPC framework. You use Slice to
specify RPCs and types used by these RPCs. It's a simple language without any execution logic: no if, no while, no
print. While you specify your RPCs in Slice, you implement the actual "business logic" using the programming language of
your choice (C#, Rust, Python...). The Slice language is an [Interface Definition Language][idl] or IDL.

- the Slice encoding\
The Slice encoding specifies how Slice language constructs such as `string`, `int32`, `float64`, `struct` are encoded
into streams of bytes. The Slice encoding is a simple, compact, binary serialization format. Most Slice users don't need
to know the details of this encoding.

Then, for each programming language that Slice supports (currently C#, and soon Rust, Python and more), Slice provides:

- a Slice language mapping\
A language mapping is a set of rules that specifies how Slice language constructs are represented in that language.
For instance, a Slice `struct` is mapped to a `struct` in C#. The C# language mapping specifies the name of this struct,
its fields, its constructors etc.

- a Slice compiler\
A language mapping is implemented by a tool—the Slice compiler—that verifies your Slice syntax and generates code from
your Slice definitions to a "mapped" programming language. In C#, the Slice compiler for C#, `slicec-cs`, compiles Slice
files into C# files. When a Slice file defines a (Slice) struct, the corresponding C# file contains the mapped C#
struct.

- a Slice library\
The code generated by the Slice compiler relies on a Slice library in the target programming language. For example, the
code generated by the Slice compiler for C# relies on [`SliceEncoder`][slice-encoder] and
[`SliceDecoder`][slice-decoder], two C# structs defined in namespace [`ZeroC.Slice`][namespace] that can encode resp.
decode a variety of types to or from byte buffers. These structs are provided by the `ZeroC.Slice` assembly and
referenced by the code generated by the Slice compiler.

And lastly, a RPC framework that supports Slice adds:

- a language mapping for Slice interfaces and operations\
The RPC framework defines how Slice interfaces and operations are mapped in the target programming language. For
example, the Slice integration provided by IceRPC for C# maps each Slice interface to two C# interfaces and one C#
struct.

- an augmented Slice compiler\
The RPC framework includes an augmented Slice compiler than generates code for Slice interfaces and operations.

- a library\
The code generated by the augmented Slice compiler uses both the Slice library, the RPC framework, and an additional
library that assists this integration. For example, the IceRPC + Slice integration in C# relies on the `IceRpc.Slice`
assembly.

All these Slice components work together to help you make RPCs without having to worry about encoding intricacies. With
IceRPC + Slice, your primary responsibility is to use the same Slice definitions in your client and server applications;
the code generated by the Slice compiler encodes and decodes your arguments and return values and exposes a high-level
easy-to-use typed API.

[idl]: https://en.wikipedia.org/wiki/Interface_description_language
[namespace]: csharp:ZeroC.Slice
[slice-decoder]: csharp:ZeroC.Slice.SliceDecoder
[slice-encoder]: csharp:ZeroC.Slice.SliceEncoder
