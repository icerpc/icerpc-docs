---
title: Enum types
description: Learn how to define enumerations in Slice.
---

## Enumeration type

An enumeration type or enum type holds a set of named constants, called enumerators, each with an associated integral
value. It is similar to enumerations found in languages like C# and C++.

The following example shows how to define an enumeration named `Fruit` with three enumerators: `Apple`, `Pear`, and
`Orange`.

{% slice2 %}
```slice
enum Fruit : uint8 { Apple, Pear, Orange }
```
{% /slice2 %}

{% slice1 %}
```slice
enum Fruit { Apple, Pear, Orange }
```
{% /slice1 %}

{% slice2 %}
An enumeration must specify the valid range of values for its enumerators with an underlying type. In the previous
example, the `Fruit` enumeration uses `uint8` as its underlying type. The underlying type can be any integral type: both
[fixed size][fixed-size] and [variable size][variable-size] integral types are accepted.
{% /slice2 %}

## Enumerator values

The default behavior of the Slice compiler is to assign values to the enumerators automatically. The first enumerator,
is assigned a value of `0`, and subsequent enumerators are assigned increasing values.

{% slice1 %}
The range of these enumerator values is 0 to 2,147,483,647 (int32 max).
{% /slice1 %}
{% slice2 %}
The range of these enumerator values is the range of the underlying types.
{% /slice2 %}

The following code example illustrates how you can explicitly assign values for the enumerators in your enumeration
type. In this example, the `Apple` enumerator is assigned a value of `1`, the `Pear` enumerator is assigned a value
of `5`, and the `Orange` enumerator is left without an explicitly assigned value.

{% slice1 %}
```slice
enum Fruit {
    Apple = 1
    Pear = 5
    Orange
}
```
{% /slice1 %}

{% slice2 %}
```slice
enum Fruit : uint8 {
    Apple = 1
    Pear = 5
    Orange
}
```
{% /slice2 %}

If you don't assign a value to an enumerator, the value of this enumerator is the value of the previous enumerator plus
one. In the `Fruit` enum above, `Orange` gets value `6`.

## Unchecked enumeration

By default, when the code generated by the Slice compiler decodes an instance of an enumeration, it makes sure this
instance corresponds to a known enumerator. This is the "checked" behavior: the decoding fails for a value with no
matching enumerator.

You can also get the opposite behavior—unchecked—by prepending `unchecked` to your enumeration definition. For example:

{% slice1 %}
```slice
unchecked enum ErrorCode {
    NotFound
    NotAuthorized
}
```
{% /slice1 %}

{% slice2 %}
```slice
unchecked enum ErrorCode : varuint62 {
    NotFound
    NotAuthorized
}
```
{% /slice2 %}

Since `ErrorCode` is marked unchecked, the generated code will successfully decode an integral value without a matching
enumerator.

A checked enumeration must have at least one enumerator, while an unchecked enumeration may have no enumerator at all.
For example, the following enumeration is valid:

{% slice1 %}
```slice
// Range: 0 to int32 max
unchecked enum MyPositiveInteger {}
```
{% /slice1 %}

{% slice2 %}
```slice
// Same range as int16
unchecked enum MyInt16 : int16 {}
```
{% /slice2 %}

## C# mapping

An enumeration maps to a public C# enumeration with the same name, and each Slice enumerator maps to the C# enumerator
with the same name. For example:

{% slice1 %}
{% side-by-side alignment="top" %}

```slice
enum Fruit { Apple, Pear, Orange }
```

```csharp
public enum Fruit : int
{
    Apple = 0,
    Pear = 1,
    Orange = 2
}
```
{% /side-by-side %}
{% /slice1 %}

{% slice2 %}
{% side-by-side alignment="top" %}
```slice
enum Fruit : uint8 { Apple, Pear, Orange }
```

```csharp
public enum Fruit : byte
{
    Apple = 0,
    Pear = 1,
    Orange = 2,
}
```
{% /side-by-side %}
{% /slice2 %}

{% slice1 %}
The underlying type of the mapped enumeration is always `int`.
{% /slice2 %}

{% slice2 %}
The underlying type of the mapped enumeration is always the mapped type for the Slice underlying type. For example,
a Slice `uint8` corresponds to a C# `byte`.
{% /slice2 %}

The Slice compiler also generates 3 extension classes for this enumeration, each with an extension method:
 - As*Name* to convert an integral value into an enum instance (with enumerator-checking for checked enums)
 - Encode*Name* to encode an enum instance
 - Decode*Name* to decode an enum instance

With our `Fruit` example, we get:

{% slice1 %}
```csharp
public static class FruitByteExtensions
{
    public static Fruit AsFruit(this int value) => ...
}

public static class FruitSliceEncoderExtensions
{
    public static void EncodeFruit(this ref SliceEncoder encoder, Fruit value) => ...
}

public static class FruitSliceDecoderExtensions
{
    public static Fruit DecodeFruit(this ref SliceDecoder decoder) => ...
}
```
{% /slice1 %}

{% slice2 %}
```csharp
public static class FruitByteExtensions
{
    public static Fruit AsFruit(this byte value) => ...
}

public static class FruitSliceEncoderExtensions
{
    public static void EncodeFruit(this ref SliceEncoder encoder, Fruit value) => ...
}

public static class FruitSliceDecoderExtensions
{
    public static Fruit DecodeFruit(this ref SliceDecoder decoder) => ...
}
```
{% /slice2 %}

### C# mapping for unchecked enum

The mapped C# API for checked and unchecked enums is the same. The difference lies in the implementations of the
As*Name* and Decode*Name* methods: these implementations check values for checked enums and don't check values for
unchecked enums.

### cs::attribute attribute

The `cs::attribute` [attribute](attributes) adds the specified C# attribute to the mapped C# enum. You typically use it
to add the [FlagsAttribute][flags-attribute] to the mapped C# enum. For example:

{% slice1 %}
{% side-by-side alignment="top" %}
```slice
[cs::attribute("Flags")]
enum MultiHue {
    None = 0,
    Black = 1,
    Red = 2,
    Green = 4,
    Blue = 8
}
```

```csharp
[Flags]
public enum MultiHue : int
{
    None = 0,
    Black = 1,
    Red = 2,
    Green = 4,
    Blue = 8,
}
```
{% /side-by-side %}
{% /slice1 %}

{% slice2 %}
{% side-by-side alignment="top" %}
```slice
[cs::attribute("Flags")]
enum MultiHue : uint8 {
    None = 0,
    Black = 1,
    Red = 2,
    Green = 4,
    Blue = 8
}
```

```csharp
[Flags]
public enum MultiHue : byte
{
    None = 0,
    Black = 1,
    Red = 2,
    Green = 4,
    Blue = 8,
}
```
{% /side-by-side %}
{% /slice2 %}

You can also apply `cs::attribute` to an enumerator to get the specified C# attribute on the mapped C# enumerator.

[fixed-size]: primitive-types#fixed-size-integral-types
[flags-attribute]: https://learn.microsoft.com/en-us/dotnet/api/system.flagsattribute
[variable-size]: primitive-types#variable-size-integral-types
