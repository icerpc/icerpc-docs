---
title: Slice
description: A better IDL
showReadingTime: false
---

## Introduction to Slice

Slice is a completely revised Interface Definition Language, [IDL], designed
for RPCs. This language allows you to define a "contract" in a programming
language neutral way. Slice can be used with any RPC framework, or with no RPC
framework at all; in particular, Slice does not depend on IceRPC. This allows
you to use IceRPC with the IDL of your choice, or no IDL at all.
The [GreeterProtobuf], [GreeterJson] and [GreeterCore] examples show how to use
IceRPC with [Protobuf], JSON and no IDL.

Nevertheless, Slice and IceRPC play well together and are often used together.
It specifies the syntax and semantics for RPCs but leaves the actual
implementation of this RPC support to external integrations.

#### Example

The Thermostat interface below defines 3 operations, or RPCs, in Slice:

```slice
interface Thermostat {
   getCurrentTemperature() -> float64
   getHistoricalTemperature(timeStamp: WellKnownTypes::TimeStamp) -> float64
   streamTemperature() -> stream float64
}
```

The Slice compiler augmented by the IceRPC + Slice integration parses this Slice interface and generates code in the
programming language of your choice. The resulting generated code offers you a convenient typed RPC API implemented
using IceRPC requests and responses.

## Clean syntax

Slice provides a readable, modern syntax inspired by Rust and Swift. Slice
supports streaming with the `stream` keyword, understands optionals with the
usual `?` suffix, requires minimal punctuation, and more.

{% slice1 %}
{% side-by-side alignment="top" %}

```protobuf
// A Person message defined with Protobuf

syntax = "proto3";

message Person {
  string name = 1;
  int32 id = 2;
  string email = 3;
}
```

```slice
// A Person class defined with Slice

class Person {
   name: string
   id: int32
   tag(1) email: string?
}
```

{% /side-by-side %}
{% /slice1 %}

{% slice2 %}
{% side-by-side alignment="top" %}

```protobuf
// A Person message defined with Protobuf

syntax = "proto3";

message Person {
  string name = 1;
  int32 id = 2;
  string email = 3;
}
```

```slice
// A Person struct defined with Slice

struct Person {
   name: string
   id: int32
   tag(1) email: string?
}
```

{% /side-by-side %}
{% /slice2 %}

Slice provides [primitive] types with clear names such as `uint16`, `float64`
and `string`, and allows you to define your own types with a few building
blocks:

- [struct]
- [enum]
- [custom]
- [Sequence]
- [Dictionary]

Last but not least, Slice's [tagged] fields and parameters allow you to update
your structs and operations over time without breaking on-the-wire
compatibility.

## Flexible and extensible

You can fine-tune the API generated by the Slice compiler with Slice [attributes]. For example, in C#, you
can map a sequence to an array (the default), or to a list, or even to a hash set:

```slice
interface Translator {
    getLanguages() -> [cs::type("HashSet<string>")] Sequence<string>
}
```

The `cs::type` attribute changes the mapping for values decoded by the generated code and returned to you. For values
you give to the generated code, the mapping for a `Sequence<string>` parameter is always `IEnumerable<string>`.

Slice's custom types allow you to send any type you wish through Slice. You just need to provide methods to encode and
decode instances of your custom type.

## Next Steps

{% grid %}

{% mini-card
   title="Slice components"
   description="A short description of each Slice component."
   href="/slice/basics/slice-components" /%}

{% mini-card
   title="Contract-first model"
   description="Learn how to create an application using IceRPC and Slice."
   href="/slice/basics/contract-first" /%}

{% mini-card
   title="Interface"
   description="Learn how to define interfaces in Slice."
   href="/slice/language-guide/interface" /%}

{% mini-card
   title="Struct"
   description="Learn how to define and use structs in Slice."
   href="/slice/language-guide/struct-types" /%}

{% mini-card
   title="Slice encoding"
   description="Learn how Slice encodes types into byte streams."
   href="/slice/encoding" /%}

{% mini-card
   title="Examples"
   description="Discover the Slice syntax through a few examples"
   href="/slice/basics/examples" /%}

{% /grid %}

[attributes]: /slice2/language-guide/attributes
[custom]: /slice2/language-guide/custom-types
[Dictionary]: /slice2/language-guide/dictionary-types
[enum]: /slice2/language-guide/enum-types
[IDL]: https://en.wikipedia.org/wiki/Interface_description_language
[primitive]: /slice2/language-guide/primitive-types
[Protobuf]: https://protobuf.dev/
[Sequence]: /slice2/language-guide/sequence-types
[struct]: /slice2/language-guide/struct-types
[tagged]: /slice2/language-guide/fields#tagged-fields
[GreeterCore]: https://github.com/icerpc/icerpc-csharp/tree/main/examples/GreeterCore
[GreeterJson]: https://github.com/icerpc/icerpc-csharp/tree/main/examples/GreeterJson
[GreeterProtobuf]: https://github.com/icerpc/icerpc-csharp/tree/main/examples/GreeterProtobuf
