---
title: Slice
description: A modern IDL and serialization format
showReadingTime: false
---

## IDL for RPCs

Slice is a new [Interface Definition Language][IDL] (IDL) that you use to model and describe your network API in a clear
and concise manner.

Defining the customary Greeter service interface in Slice is straightforward:

```slice
interface Greeter {
    greet(name: string) -> string
}
```

You don't need to craft special request and reply message types for the `greet` operation: you can specify all your
parameters inline.

## Slice and IceRPC

You can use Slice with any RPC framework, or with no RPC framework at all. Slice is a separate framework that does not
depend on IceRPC.

That being said, Slice and IceRPC were developed in tandem and together form what you would typically understand as an
"RPC framework".

This chapter describes both Slice and the IceRPC + Slice integration provided by IceRPC.

## Streamlined syntax

{% slice1 %}
In the Slice1 [compilation mode], Slice is a thorough revision of the [original Slice] language: it offers the same
constructs (interface, class, struct, etc.) and capabilities but with a simpler syntax inspired by Rust and Swift.

The Slice2 compilation mode provides additional features that have no equivalent in the original Slice, such as streamed
parameters and variable-size integer types. You should use Slice1 only for interop with Ice applications.

#### Example

{% side-by-side alignment="top" %}

```ice {% title="Slice definitions (original Ice syntax)" %}
class Person
{
   string name;
   optional(1) string nickname;
   string email;
}

sequence<Person> PersonList;

interface Contacts
{
   PersonList find(string searchExpression);
}
```

```slice {% title="Slice definitions (new syntax)" %}
mode = Slice1

interface Contacts {
   find(searchExpression: string) -> Sequence<Person>
}

class Person {
   name: string
   tag(1) nickname: string?
   email: string
}
```
{% /side-by-side %}

See more examples on the [Converting .ice into .slice] page.
{% /slice1 %}

{% slice2 %}
Slice provides a readable, modern syntax inspired by Rust and Swift. It includes support for streaming parameters with
the `stream` keyword, allows you to turn any type into an optional type with the `?` suffix, requires minimal
punctuation, and more.

The Slice [primitive] types have clear names such as `uint8`, `float64`, and `string`. Slice also includes two built-in
generic types, [Sequence] and [Dictionary]. And Slice lets you define your own types with [custom], [enum], and [struct].

Last but not least, Slice's [tagged] fields and parameters allow you to update your structs and operations over time
without breaking on-the-wire compatibility.

#### Example

```slice
// A TourGuide interface with an operation that describes an attraction defined with Slice.
interface TourGuide {
    audioDescription(attraction: string) -> (
        title: string
        duration: WellKnownTypes::Duration
        recording: stream uint8
    )
}
```
{% /slice2 %}

## Code generation

Once you've described your RPCs in Slice, you run the Slice compiler on your Slice definitions to generate code in the
programming language of your choice. This generated code makes it easy to send requests to a remote service and later
receive the corresponding responses. It also helps you implement this remote service by providing a template to
fill-in.

For example, the Slice compiler for C# generates two C# interfaces and a struct from the interface `Greeter` shown
earlier:

```csharp {% title="C# generated code - client-side" %}
public partial interface IGreeter
{
   Task<string> GreetAsync(
      string name,
      IFeatureCollection? features = null,
      CancellationToken cancellationToken = default);
}

public readonly partial record struct GreeterProxy : IGreeter, IProxy
{
   public Task<string> GreetAsync(
      string name,
      IFeatureCollection? features = null,
      CancellationToken cancellationToken = default)
      {
         // implemented using IceRPC...
      }
}
```

```csharp {% title="C# generated code - server-side" %}
public partial interface IGreeterService
{
   ValueTask<string> GreetAsync(
      string name,
      IFeatureCollection features,
      CancellationToken cancellationToken);
}
```

{% callout %}
The C# code shown above is generated by the Slice compiler augmented by the IceRPC + Slice integration. In particular,
[IFeatureCollection] is an IceRPC type.
{% /callout %}

## Flexible and extensible

You can fine-tune the API generated by the Slice compiler with Slice [attributes]. For example, in C#, you can map a
sequence to an array (the default), or to a list, or even to a hash set:

```slice
interface Translator {
    getLanguages() -> [cs::type("HashSet<string>")] Sequence<string>
}
```

The `cs::type` attribute changes the mapping for values decoded by the generated code and returned to you. For values
you give to the generated code, the mapping for a `Sequence<string>` parameter is always `IEnumerable<string>`.

Slice's custom types allow you to send any type you wish through Slice. You just need to provide methods to encode and
decode instances of your custom type.

## Next steps

{% grid %}

{% mini-card
   title="Slice components"
   description="An overview of each Slice component."
   href="/slice/basics/slice-components" /%}

{% mini-card
   title="Contract-first model"
   description="Learn how to create an application using IceRPC and Slice."
   href="/slice/basics/contract-first" /%}

{% mini-card
   title="Interface"
   description="Learn how to define interfaces in Slice."
   href="/slice/language-guide/interface" /%}

{% mini-card
   title="Struct"
   description="Learn how to define and use structs in Slice."
   href="/slice/language-guide/struct-types" /%}

{% mini-card
   title="Slice encoding"
   description="Learn how Slice encodes types into byte streams."
   href="/slice/encoding" /%}

{% mini-card
   title="Examples"
   description="Discover the Slice syntax through a few examples"
   href="/slice/basics/examples" /%}

{% /grid %}

[attributes]: /slice/language-guide/attributes
[compilation mode]: /slice/language-guide/compilation-mode
[Converting .ice into .slice]: /icerpc-for-ice-users/slice/converting-ice-into-slice
[custom]: /slice/language-guide/custom-types
[Dictionary]: /slice/language-guide/dictionary-types
[enum]: /slice/language-guide/enum-types
[IDL]: https://en.wikipedia.org/wiki/Interface_description_language
[IFeatureCollection]: csharp:IceRpc.Features.IFeatureCollection
[original Slice]: https://doc.zeroc.com/ice/3.7/the-slice-language
[primitive]: /slice/language-guide/primitive-types
[Sequence]: /slice/language-guide/sequence-types
[struct]: /slice/language-guide/struct-types
[tagged]: /slice/language-guide/fields#tagged-fields
