---
title: One syntax, two encodings
description: Learn about the new Slice provided by IceRPC.
---

## One syntax

The Slice compilers provided by IceRPC understand only the new Slice syntax and compilation model, and compile only
Slice definitions stored in .slice files. These Slice compilers don't understand Ice's .ice syntax and they don't read
or compile .ice files.

## Two encodings

With Ice, the (Ice) encoding version to use when sending a request is a runtime decision. You can reconfigure your proxy
to use encoding version 1.0, for example:
```csharp {% title="Setting the encoding version with Ice for C#" %}
helloPrx = helloPrx.ice_encodingVersion(Ice.Util.Encoding_1_0);
```

Ice's Slice engine together with the code generated by the Slice compiler will dutifully encode the arguments of the
requests sent by this proxy with Ice's encoding version 1.0.

With IceRPC's Slice, the encoding to use is a Slice compile-time decision. When you define an interface, this interface
specifies unambiguously the encoding to use when encoding operation arguments and return values. The selected encoding
is hard-coded in the generated code. This encoding is specified at the top of each Slice file with the encoding
statement and applies to all definitions in the file:
```slice
encoding = Slice1
```
or
```slice
encoding = Slice2
```

The Slice1 encoding is an exact match for Ice's encoding version 1.1. The Slice2 encoding is a new encoding introduced
in IceRPC; an Ice application cannot decode a byte stream encoded with Slice2.

A Slice file without an encoding statement uses the default encoding, Slice2.

## Encoding and syntax

Your .slice file's encoding determines which definitions are allowed in that file.

_Slice1_

This encoding provides an equivalent syntax for all Slice definitions in .ice syntax, including class, exceptions,
interfaces and structs. The names are mostly the same: for example, a class in a .ice file corresponds to a
class in a .slice file, and a struct in a .ice file corresponds to a compact struct in a .slice file.

You should use this encoding when (and only when) you need to send or receive requests from Ice applications.

_Slice2_

This is the default encoding and the preferred encoding when you don't need interop with Ice applications.

This encoding allows you to mark any type as optional with the `?` suffix. For example:
```slice
// with encoding = Slice2

interface Hello {
    // Both the "name" argument and the return value can be "not set".
    sayHello(name: string?) -> string?
}
```

Slice2 also provides:
 - unsigned integer types such as uint32
 - variable-size integer types such as varint64
 - underlying types for enums
 - structs that can be augmented while maintaining on-the-wire compatibility

However, Slice2 is not a superset of Slice1. The following constructs are only accepted with Slice1:
 - classes, including AnyClass
 - exceptions with a base exception
 - AnyException in exception specifications

_New constructs_

The .slice syntax adds a few constructs that are available with both Slice1 and Slice2 but have no equivalent with the
.ice syntax, namely:
 - anonymous sequences and dictionaries\
   You can now use `sequence<string>` directly as a parameter or field type.
 - custom types\
   A custom type is a type that you encode and decode yourself in all language mappings.
 - typealias\
   A typealias is a new name for another type.
