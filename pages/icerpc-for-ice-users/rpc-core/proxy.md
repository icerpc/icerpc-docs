---
title: Proxy
description: Understand the new IceRPC syntax for proxy strings.
---

## Service address

An Ice proxy designates a programming language construct generated by the Slice compiler that you use to send requests
to a remote Ice object. This construct is also called a proxy by the new Slice language and the IceRPC +
Slice integration.

With the IceRPC + Slice integration, you use a (Slice) proxy to make invocations on a remote service.

An Ice proxy can also designate the address of a remote Ice object. It's this address that gets encoded when you send a
proxy through a Slice operation. You can get a string representation of this address when you call "to string" on a
proxy, and you can convert this string representation into an Ice proxy when you call `stringToProxy` on your
communicator.

In IceRPC, this address is called a [service address][service-address]. It doesn't depend on Slice.

## String syntax

Ice uses its own syntax for proxy strings, while IceRPC uses URIs for service addresses. The object identity in a proxy
string is mapped to an absolute path in the service address URI as described in [Ice identity](ice-identity).

Here are a few examples:

| Ice proxy string                                  | Corresponding IceRPC service address URI                               |
| ------------------------------------------------- | ---------------------------------------------------------------------- |
| `hello:tcp -h localhost -p 10000`                 | `ice://localhost:10000/hello?transport=tcp`                            |
| `IceGrid/Locator:default -h 192.168.1.2 -p 10000` | `ice://192.168.1.2:10000/IceGrid/Locator`                              |
| `hello:tcp -h h1 -p 10000:tcp -h h2 -p 10000`     | `ice://h1:10000/hello?transport=tcp&alt-server=h2:10000?transport=tcp` |

## Indirect proxies

In Ice, a proxy without an endpoint is called an "indirect proxy". When you send a request to such a proxy, you need a
Locator to locate the actual endpoints of this proxy.

In IceRPC, a service address without a server address has no special name: it's just a service address without a server
address.

When the IceRPC + Slice integration decodes a Slice1-encoded proxy with no server address but with an adapter ID, it
creates a service address with an adapter-id parameter. For example:

| Proxy to decode (with Ice proxy string syntax) | Decoded as                             |
| ---------------------------------------------- | -------------------------------------- |
| `hello`                                        | `ice:/hello`                           |
| `hello@GreetersUnited`                         | `ice:/hello?adapter-id=GreetersUnited` |

## Proxy options

Ice proxy strings support a number of options: `-f facet`, `-e encoding` `-p protocol`, `-t` (for two-way), `-s` (for
secure) and more.

When the IceRPC + Slice integration decodes a Slice1-encoded proxy, it processes these options as follows:

- convert protocol "1.0" into ice and protocol "2.0" into icerpc (any other value is invalid)
- convert the facet into the service address fragment when the protocol is ice (else decoding failure)
- all other options are ignored

As a result, the Slice engine's proxy-to-service-address decoding is lossy, unlike the
[endpoint-to-server-address](../endpoint#endpoint-options) decoding.

For example:

| Proxy to decode (with Ice proxy string syntax) | Decoded as                                        |
| ---------------------------------------------- | ------------------------------------------------- |
| `hello -f facet:tcp -h localhost -p 10000`     | `ice://localhost:10000/hello?transport=tcp#facet` |
| `hello -p 2.0:ssl -h localhost -p 10000`       | `icerpc://localhost:10000/hello?transport=ssl`    |
| `hello -o -s:ssl -h localhost -p 10000`        | `ice://localhost:10000/hello?transport=ssl`       |
| `hello -t`                                     | `ice:/hello`                                      |

[service-address]: /icerpc/invocation/service-address
