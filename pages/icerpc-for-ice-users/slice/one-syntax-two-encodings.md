---
title: New Slice syntax
description: Learn about the new Slice provided by IceRPC.
---

## New syntax

The Slice compilers for the new Slice language understand only the new Slice syntax and compilation model. They accept
only Slice definitions saved in .slice files. These Slice compilers don't understand Ice's .ice syntax and they don't
read or compile .ice files.

## Compilation mode

With Ice, the Ice/Slice encoding version to use when sending a request is a runtime decision. You can reconfigure a
proxy to use the encoding version of your choice. For example:
```csharp {% title="Setting the encoding version with Ice for C#" %}
helloPrx = helloPrx.ice_encodingVersion(Ice.Util.Encoding_1_0);
```

Ice's Slice library together with the code generated by the Slice compiler then dutifully encodes the arguments of the
requests sent by this proxy with Ice's encoding version 1.0.

With the new Slice language, the encoding to use is decided at build-time, when you compile your Slice file. When you
define an interface, the encoding to use to encode operation arguments and return values is specified unambiguously with
the [mode statement](/slice1/language-guide/compilation-mode), and gets hard-coded in the generated code.

#### Example

```slice
mode = Slice1
```
or
```slice
mode = Slice2
```

The Slice1 mode selects the Slice1 encoding, and this Slice1 encoding is an exact match for Ice's encoding version 1.1.
The Slice2 mode selects the Slice2 encoding, a new encoding introduced in IceRPC; an Ice application cannot decode a
byte stream encoded with Slice2.

A Slice file that doesn't specify a compilation mode uses the default mode: Slice2.

## Compilation mode and syntax

Your .slice file's compilation mode determines which definitions are allowed in that file.

_Slice1_

This mode provides an equivalent syntax for all Slice definitions in .ice syntax, including class, exceptions,
interfaces and structs. The names are mostly the same: for example, a class in a .ice file corresponds to a
class in a .slice file, and a struct in a .ice file corresponds to a compact struct in a .slice file.

You should use this mode when (and only when) you need to send or receive requests to and from Ice applications.

_Slice2_

This is the default mode and the preferred mode when you don't need interop with Ice applications.

This mode allows you to mark any type as optional with the `?` suffix. For example:
```slice
// Implicitly uses `mode = Slice2`

interface Translator {
    // Both the "message" argument and the return value can be "not set".
    translate(message: string?) -> string?
}
```

Slice2 also provides:
 - stream parameters and return values
 - unsigned integer types such as uint32
 - variable-size integer types such as varint64
 - underlying types for enums
 - structs that can be augmented while maintaining on-the-wire compatibility

However, Slice2 is not a superset of Slice1. The following constructs are only accepted with Slice1:
 - classes, including AnyClass
 - exceptions with a base exception
 - AnyException in exception specifications

## New constructs

The .slice syntax adds a few constructs that are available with both Slice1 and Slice2 but have no equivalent with the
.ice syntax, namely:
 - anonymous sequences and dictionaries\
   You can now use `sequence<string>` directly as a parameter or field type.
 - custom types\
   A custom type is a type that you encode and decode yourself in all language mappings.
 - typealias\
   A typealias is a new name for another type.
