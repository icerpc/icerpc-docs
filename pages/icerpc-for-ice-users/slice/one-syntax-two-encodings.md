---
title: One syntax, two encodings
description: Learn about the new Slice provided by IceRPC.
---

## One syntax

The Slice compilers provided by IceRPC understand only the new Slice syntax and compilation model, and compile only
Slice definitions saved in .slice files. These Slice compilers don't understand Ice's .ice syntax and they don't read
or compile .ice files.

## Two encodings

With Ice, the Ice/Slice encoding version to use when sending a request is a runtime decision. You can reconfigure a
proxy to use the encoding version of your choice. For example:
```csharp {% title="Setting the encoding version with Ice for C#" %}
helloPrx = helloPrx.ice_encodingVersion(Ice.Util.Encoding_1_0);
```

Ice's Slice library together with the code generated by the Slice compiler then dutifully encodes the arguments of the
requests sent by this proxy with Ice's encoding version 1.0.

With IceRPC's Slice, the encoding to use is a Slice compile-time decision. When you define an interface, this interface
specifies unambiguously the encoding to use when encoding operation arguments and return values. The selected encoding
is hard-coded in the generated code. This encoding is specified at the top of each Slice file with the encoding
statement and applies to all definitions in the file:
```slice
encoding = Slice1
```
or
```slice
encoding = Slice2
```

The Slice1 encoding is an exact match for Ice's encoding version 1.1. The Slice2 encoding is a new encoding introduced
in IceRPC; an Ice application cannot decode a byte stream encoded with Slice2.

A Slice file without an encoding statement uses the default encoding, Slice2.

## Encoding and syntax

Your .slice file's encoding determines which definitions are allowed in that file.

_Slice1_

This encoding provides an equivalent syntax for all Slice definitions in .ice syntax, including class, exceptions,
interfaces and structs. The names are mostly the same: for example, a class in a .ice file corresponds to a
class in a .slice file, and a struct in a .ice file corresponds to a compact struct in a .slice file.

You should use this encoding when (and only when) you need to send or receive requests from Ice applications.

_Slice2_

This is the default encoding and the preferred encoding when you don't need interop with Ice applications.

This encoding allows you to mark any type as optional with the `?` suffix. For example:
```slice
// with encoding = Slice2

interface Translator {
    // Both the "message" argument and the return value can be "not set".
    translate(message: string?) -> string?
}
```

Slice2 also provides:
 - stream parameters and return values
 - unsigned integer types such as uint32
 - variable-size integer types such as varint64
 - underlying types for enums
 - structs that can be augmented while maintaining on-the-wire compatibility

However, Slice2 is not a superset of Slice1. The following constructs are only accepted with Slice1:
 - classes, including AnyClass
 - exceptions with a base exception
 - AnyException in exception specifications

## New constructs

The .slice syntax adds a few constructs that are available with both Slice1 and Slice2 but have no equivalent with the
.ice syntax, namely:
 - anonymous sequences and dictionaries\
   You can now use `sequence<string>` directly as a parameter or field type.
 - custom types\
   A custom type is a type that you encode and decode yourself in all language mappings.
 - typealias\
   A typealias is a new name for another type.
