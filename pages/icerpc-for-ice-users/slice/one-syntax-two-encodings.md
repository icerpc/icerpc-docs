---
title: One syntax, two encodings
description: Learn about the new Slice provided by IceRPC.
---

## One syntax

The Slice compilers provided by IceRPC understand only the new Slice syntax and compilation model, and compile only
Slice definitions saved in .slice files. These Slice compilers don't understand Ice's .ice syntax and they don't read
or compile .ice files.

## Two encodings

With Ice, the Ice/Slice encoding version to use when sending a request is a runtime decision. You can reconfigure a
proxy to use the encoding version of your choice. For example:
```csharp {% title="Setting the encoding version with Ice for C#" %}
helloPrx = helloPrx.ice_encodingVersion(Ice.Util.Encoding_1_0);
```

Ice's Slice library together with the code generated by the Slice compiler then dutifully encodes the arguments of the
requests sent by this proxy with Ice's encoding version 1.0.

With IceRPC's Slice, the encoding to use is a Slice compile-time decision. When you define an interface, the encoding
that will be used to encode operation arguments and return values is specified unambiguously, and gets hard-coded in
the generated code. This encoding can be specified at the top of a Slice file with the
[mode statement](/slice1/language-guide/compilation-mode) and applies to all interfaces defined in that file:

```slice
mode = Slice1
```
or
```slice
mode = Slice2
```

The Slice1 encoding is an exact match for Ice's encoding version 1.1. The Slice2 encoding is a new encoding introduced
in IceRPC; an Ice application cannot decode a byte stream encoded with Slice2.

A Slice file that doesn't specify a compilation mode uses the default mode: Slice2.

## Encoding and syntax

Your .slice file's compilation mode determines which definitions are allowed in that file.

_Slice1_

This mode provides an equivalent syntax for all Slice definitions in .ice syntax, including class, exceptions,
interfaces and structs. The names are mostly the same: for example, a class in a .ice file corresponds to a
class in a .slice file, and a struct in a .ice file corresponds to a compact struct in a .slice file.

You should use this mode when (and only when) you need to send or receive requests from Ice applications.

_Slice2_

This is the default mode and the preferred mode for when you don't need interop with Ice applications.

This mode allows you to mark any type as optional with the `?` suffix. For example:
```slice
// Implicitly uses `mode = Slice2`

interface Translator {
    // Both the "message" argument and the return value can be "not set".
    translate(message: string?) -> string?
}
```

Slice2 also provides:
 - stream parameters and return values
 - unsigned integer types such as uint32
 - variable-size integer types such as varint64
 - underlying types for enums
 - structs that can be augmented while maintaining on-the-wire compatibility

However, Slice2 is not a superset of Slice1. The following constructs are only accepted with Slice1:
 - classes, including AnyClass
 - exceptions with a base exception
 - AnyException in exception specifications

## New constructs

The .slice syntax adds a few constructs that are available with both Slice1 and Slice2 but have no equivalent with the
.ice syntax, namely:
 - anonymous sequences and dictionaries\
   You can now use `sequence<string>` directly as a parameter or field type.
 - custom types\
   A custom type is a type that you encode and decode yourself in all language mappings.
 - typealias\
   A typealias is a new name for another type.
