---
title: New Slice
description: Get started with the new Slice language.
---

## Slice compilers

The Slice compilers for the new Slice language understand only the new Slice syntax and compilation model. They only
accept Slice definitions saved in `.slice` files. These Slice compilers don't understand the Slice syntax used by Ice
and they don't read or compile `.ice` files.

As a result, you need to [convert][convert] your `.ice` files into `.slice` files to use IceRPC with your existing Ice
applications.

## Compilation mode and encoding version

With Ice, the version of the Ice encoding to use when sending a request is a runtime decision. You can reconfigure a
proxy to use the version of your choice. For example:
```csharp {% title="Setting the Ice encoding version with Ice for C#" %}
helloPrx = helloPrx.ice_encodingVersion(Ice.Util.Encoding_1_0);
```

The Ice runtime together with the code generated by the Slice compiler then dutifully encodes the arguments of the
requests sent by this proxy with version 1.0 of the Ice encoding.

With the new Slice language, the encoding to use is decided at build-time, when you compile your Slice file. When you
define an interface, the encoding for operation arguments and return values is specified unambiguously with the
[mode statement](/slice1/language-guide/compilation-mode), and gets hard-coded in the generated code.

#### Example

```slice
mode = Slice1
```
or
```slice
mode = Slice2
```

The Slice1 mode selects the Slice1 encoding; this Slice1 encoding is an exact match for version 1.1 of the Ice encoding.
The Slice2 mode selects the Slice2 encoding, a new encoding that Ice applications do not understand and cannot decode.

A Slice file that doesn't specify a compilation mode uses the default mode: Slice2.

## Compilation mode and syntax

The compilation mode also determines which definitions are allowed in your Slice file.

#### Slice1

This mode provides an equivalent syntax for all Slice definitions in the .ice syntax, including classes, exceptions,
interfaces, and structs. The names are mostly the same: for example, a class in a `.ice` file corresponds to a
class in a `.slice` file, and a struct in a `.ice` file corresponds to a compact struct in a `.slice` file.

You should use this mode when (and only when) you need to send or receive requests to and from Ice applications.

#### Slice2

This is the default mode and the preferred mode when you don't need interop with Ice applications.

This mode allows you to mark any type as optional with the `?` suffix. For example:
```slice
// Implicitly uses `mode = Slice2`

interface Translator {
    // Both the "message" argument and the return value can be "not set".
    translate(message: string?) -> string?
}
```

Slice2 also provides:
 - stream parameters
 - unsigned integer types such as uint32
 - variable-size integer types such as varint64
 - underlying types for enums
 - structs that can be augmented while maintaining on-the-wire compatibility

However, Slice2 is not a superset of Slice1. The following constructs are only accepted in Slice1 mode:
 - classes, including AnyClass
 - exceptions with a base exception
 - AnyException in exception specifications

## New constructs

The .slice syntax adds a few constructs that are available with both Slice1 and Slice2 but have no equivalent with the
.ice syntax, namely:
 - anonymous sequences and dictionaries\
   You can now use `sequence<string>` directly as a parameter or field type.
 - custom types\
   A custom type is a type that you encode and decode yourself in all language mappings.
 - typealias\
   A typealias is a new name for another type.

[convert]:  converting-ice-into-slice
