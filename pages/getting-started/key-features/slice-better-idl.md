---
title: Slice - a better IDL
---

## New RPC framework => new IDL?

Most RPC frameworks provide an [Interface Definition Language][idl] (IDL) and a compiler for this IDL. This language
allows you to define a "contract" in a programming language neutral way, and then compile this contract into your target
programming language(s). The typical and sometimes only way to use an RPC framework is with this bundled IDL.

IceRPC takes a different approach by providing a very usable byte-oriented API for requests and responses. This allows
you to use IceRPC with the IDL of your choice, or no IDL at all. The [GreeterProtobuf][greeter-protobuf],
[GreeterJson][greeter-json] and [GreeterCore][greeter-core] examples show how to use IceRPC with resp.
[Protobuf][protobuf], JSON and no IDL.

That said, the easiest way to write applications with IceRPC is with [Slice][slice].

## Better IDL for RPCs

Slice is a completely revised IDL designed for RPCs. Slice can be used with any RPC framework, or with no RPC framework
at all; in particular, Slice does not depend on IceRPC. Nevertheless, Slice and IceRPC play well together and are often
used together.

With Slice, a service implements one or more Slice interfaces, and each Slice interface holds one or more operations.
For example:

```slice
/// Represents a simple greeter.
interface Greeter {
    /// Creates a personalized greeting.
    /// @param name: The name of the person to greet.
    /// @returns: The greeting.
    greet(name: string) -> string
}
```

An operation accepts and returns any number of parameters. The last parameter in each direction can be a stream as
illustrated below:

```slice
/// Represents a tour guide.
interface TourGuide {
    /// Describes an attraction.
    /// @returns title: The text to display on the electronic tour guide device.
    /// @returns duration: The duration of the recording.
    /// @returns recording: The audio recording in M4A format.
    audioDescription(attraction: string) -> (
        title: string
        duration: WellKnownTypes::Duration
        recording: stream uint8
    )
}
```

An operation can also return a custom error, specified with a `throws`:

```slice
interface Translator {
    translate(message: string) -> string throws TranslationException
}

exception TranslationException {
    pos: int32
    detectedLanguage: string?
}
```

{% callout %}
The `throws` syntax may evoke the now abandoned checked exception pattern first championed by Java. But that's not the
correct analogy: `throws` is actually equivalent to `Result<Success, Failure>` in Rust and Swift, where an operation
returns one type on success and another type on failure.
{% /callout %}

## Clean syntax

As shown in the examples above, Slice provides a readable, modern syntax inspired by Rust and Swift. Slice supports
streaming with the `stream` keyword, understands optionals with the usual `?` suffix, requires minimal punctuation, and
more.

Slice provides [primitive][primitive] types with clear names such as `uint16`, `float64` and `string`, and allows you to
define your own types with a few building blocks:
 - [struct][struct]
 - [exception][exception]
 - [enum][enum]
 - [sequence][sequence]
 - [dictionary][dictionary]
 - [custom][custom]

Last but not least, Slice's [tagged][tagged] fields and parameters allow you to update your structs and operations over
time without breaking on-the-wire compatibility.

## Flexible and extensible

You can fine-tune the API generated by the Slice compiler with Slice [attributes][attributes]. For example, in C#, you
can map a sequence to an array (the default), or to a list, or even to a hash set:

```slice
interface Translator {
    getLanguages() -> [cs::type("HashSet<string>")] sequence<string>
}
```

The `cs::type` attribute changes the mapping for values decoded by the generated code and returned to you. For values
you give to the generated code, the mapping for a `sequence<string>` parameter is always `IEnumerable<string>`.

Slice's custom types allow you to send any type you wish through Slice. You just need to provide methods to encode and
decode instances of your custom type.

The [well-known][well-known] types `Duration`, `TimeStamp` and `Uri` are custom types included in all Slice
implementations; in C#, they correspond to System typesâ€”`TimeSpan`, `DateTime` and `Uri`.

```slice
[cs::namespace("ZeroC.Slice")]
module WellKnownTypes

/// Represents a length of time, encoded as a varint62.
/// Precision: 100 nanoseconds.
[cs::type("System.TimeSpan")]
custom Duration
```

[attributes]: /slice2/language-guide/attributes
[custom]: /slice2/language-guide/custom-types
[dictionary]: /slice2/language-guide/dictionary-types
[enum]: /slice2/language-guide/enum-types
[exception]: /slice2/language-guide/exception
[idl]: https://en.wikipedia.org/wiki/Interface_description_language
[greeter-core]: https://github.com/icerpc/icerpc-csharp/tree/main/examples/GreeterCore
[greeter-json]: https://github.com/icerpc/icerpc-csharp/tree/main/examples/GreeterJson
[greeter-protobuf]: https://github.com/icerpc/icerpc-csharp/tree/main/examples/GreeterProtobuf
[primitive]: /slice2/language-guide/primitive-types
[protobuf]: https://en.wikipedia.org/wiki/Protocol_Buffers
[sequence]: /slice2/language-guide/sequence-types
[slice]: /slice2
[struct]: /slice2/language-guide/struct-types
[tagged]: /slice2/language-guide/fields#tagged-fields
[well-known]: /slice2/language-guide/well-known-types
