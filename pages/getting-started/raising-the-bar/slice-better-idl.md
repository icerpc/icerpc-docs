---
title: Slice - a better IDL
---

## New RPC framework => new IDL?

Most RPC frameworks provide an [Interface Definition Language][idl] (IDL) and a compiler for this IDL. This language
allows you to define a "contract" in a programming language neutral way, and then compile this contract into your target
programming language(s). The typical and sometimes only way to use an RPC framework is with this bundled IDL.

For example, [gRPC][grpc]'s IDL is Protobuf and you'd be hard pressed to find examples of gRPC applications that don't
use Protobuf.

IceRPC takes a different approach by providing a very usable byte-oriented API for requests and responses. This allows
you to use IceRPC with the IDL of your choice, or no IDL at all. The [GreeterProtobuf][greeter-protobuf],
[GreeterJson][greeter-json] and [GreeterCore][greeter-core] examples show how to use IceRPC with resp. Protobuf, JSON
and no IDL.

IceRPC also provides its own IDL, [Slice][slice]. We believe you'll want to use Slice with IceRPC because Slice is a
better IDL, not because that's your only choice.

## Better IDL for RPCs

Slice is a completely revised IDL designed for RPCs. And naturally, Slice is fully integrated with IceRPC.

With IceRPC + Slice, a service implements one or more Slice interfaces, and each Slice interface holds one or more
operations. For example:

```slice
/// Represents a simple greeter.
interface Greeter {
    /// Creates a personalized greeting.
    /// @param name: The name of the person to greet.
    /// @returns: The greeting.
    greet(name: string) -> string
}
```

An operation accepts and returns any number of parameters. The last parameter in each direction can be a stream as
illustrated below:

```slice
/// Represents a tour guide.
interface TourGuide {
    /// Describes an attraction.
    /// @returns title: The text to display on the electronic tour guide device.
    /// @returns duration: The duration of the recording.
    /// @returns recording: The audio recording in M4A format.
    audioDescription(attraction: string) -> (
        title: string
        duration: WellKnownTypes::Duration
        recording: stream uint8
    )
}
```

An operation can also return a custom error, specified with a `throws`:

```slice
interface Translator {
    translate(message: string) -> string throws TranslationException
}

exception TranslationException {
    pos: int32
    detectedLanguage: string?
}
```

{% callout %}
The `throws` syntax may evoke the now abandoned checked exception pattern first championed by Java. But that's not the
correct analogy: `throws` is actually equivalent to `Result<Success, Failure>` in Rust and Swift, where an operation
returns one type on success and another type on failure.
{% /callout %}

## Clean syntax

As shown in the examples above, Slice provides a readable, modern syntax inspired by Rust and Swift. Slice supports
streaming with the `stream` keyword, understands optionals with the usual `?` suffix, requires minimal punctuation, and
more.

In addition to [primitive][primitive] types with clear names such as `uint16`, `float64` and `string`, Slice provides a
few constructed types—the building blocks for more advanced applications:
 - [struct][struct]
 - [exception][exception]
 - [enum][enum]
 - [sequence][sequence]
 - [dictionary][dictionary]
 - [custom][custom]

Last but not least, Slice's [tagged][tagged] parameters and fields allow you to update your operations and structs over
time without breaking on-the-wire compatibility.

## Flexible and extensible

You can fine-tune the API generated by the Slice compiler with Slice [attributes][attributes]. For example, in C#, you
can map a sequence to an array (the default), or to a list, or even to a hash set:

```slice
interface Translator {
    getLanguages() -> [cs::type("HashSet<string>")] sequence<string>
}
```

The `cs::type` attribute changes the mapping for values decoded by the generated code and returned to you. For values
you give to the generated code, the mapping for a `sequence<string>` parameter is always `IEnumerable<string>`.

Slice's custom types allow you to send any type you wish through Slice. You just need to provide methods to encode and
decode instances of your custom type.

The [well-known][well-known] types `Duration`, `TimeStamp` and `Uri` are custom types included in all IceRPC
implementations; in C#, they correspond to the System types you'd expect—`TimeSpan`, `DateTime` and `Uri`.

```slice
[cs::namespace("IceRpc.Slice")]
module WellKnownTypes

/// Represents a length of time, encoded as a varint62.
/// Precision: 100 nanoseconds.
[cs::type("System.TimeSpan")]
custom Duration
```

[attributes]: ../../slice/language-guide/attributes
[custom]: ../../slice/language-guide/custom-types
[dictionary]: ../../slice/language-guide/dictionary-types
[enum]: ../../slice/language-guide/enum-types
[exception]: ../../slice/language-guide/exception
[grpc]: https://grpc.io/
[idl]: https://en.wikipedia.org/wiki/Interface_description_language
[greeter-core]: https://github.com/icerpc/icerpc-csharp/tree/main/examples/GreeterCore
[greeter-json]: https://github.com/icerpc/icerpc-csharp/tree/main/examples/GreeterJson
[greeter-protobuf]: https://github.com/icerpc/icerpc-csharp/tree/main/examples/GreeterProtobuf
[primitive]: ../../slice/language-guide/primitive-types
[sequence]: ../../slice/language-guide/sequence-types
[slice]: ../../slice
[struct]: ../../slice/language-guide/struct-types
[tagged]: ../../slice/language-guide/parameters-and-fields#tagged-parameters-and-fields
[well-known]: ../../slice/language-guide/well-known-types
