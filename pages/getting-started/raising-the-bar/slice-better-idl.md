---
title: Slice - a better IDL
---

## New RPC framework => new IDL?

Most RPC frameworks provide an [Interface Definition Language][idl] (IDL) and a compiler for this IDL. This language
allows you to define a "contract" in a programming language neutral way, and then compile this contract into your target programming language(s). The typical and sometimes only way to use a RPC framework is with this bundled IDL.

For example, [gRPC][grpc]'s IDL is Protobuf and you'd be hard pressed to find examples of gRPC applications that don't
use Protobuf.

IceRPC takes a different approach by providing a very usable byte-oriented API for requests and responses. This allows
you to use IceRPC with the IDL of your choice, or no IDL at all. The [GreeterProtobuf][greeter-protobuf],
[GreeterJson][greeter-json] and [GreeterCore][greeter-core] examples show how to use IceRPC with resp. Protobuf, JSON
and no IDL.

IceRPC also provides its own IDL, [Slice][slice]. We believe you'll want to use Slice with IceRPC because Slice is a
better IDL, not because that's your only choice.

## Better IDL for RPCs

Slice is a completely revised IDL designed for RPCs. And naturally, Slice is fully integrated with IceRPC.

With IceRPC + Slice, a service implements one or more Slice interfaces, and each Slice interface holds one or more
operations. For example:

```slice
/// Represents a simple greeter.
interface Greeter {
    /// Creates a personalized greeting.
    /// @param name: The name of the person to greet.
    /// @returns: The greeting.
    greet(name: string) -> string
}
```

An operation accepts and returns any number of parameters. The last parameter in each direction can be a stream as
illustrated below:

```slice
/// Represents a tour guide.
interface TourGuide {
    /// Describes an attraction.
    /// @returns title: The text to display on the electronic tour guide device.
    /// @returns duration: The duration of the recording.
    /// @returns recording: The audio recording in M4A format.
    audioDescription(attraction: string) -> (
        title: string
        duration: WellKnownTypes::Duration
        recording: stream uint8
    )
}
```

An operation can also return a custom error, specified with a `throws`:

```slice
interface Translator {
    translate(message: string) -> string throws TranslationException
}

exception TranslationException {
    pos: int32
    detectedLanguage: string?
}
```

{% callout %}
The `throws` syntax may evoke the now abandoned checked exception pattern first championed by Java. But that's not the
correct analogy: `throws` is actually equivalent to `Result<Success, Failure>` in Rust and Swift, where an operation
returns one type on success and another type on failure.
{% /callout %}

## Clean syntax

As shown in the examples above, Slice provides a readable, modern syntax inspired by Rust and Swift. Slice supports
streaming with the `stream` keyword, understands optionals with the usual `?` suffix, requires minimal punctuation, and
more.

In addition to [primitive][primitive] types with clear names such as `uint16`, `float64` and `string`, Slice provides a
few constructed types—the building blocks for more advanced applications:
 - [struct][struct]
 - [exception][exception]
 - [enum][enum]
 - [sequence][sequence]
 - [dictionary][dictionary]
 - [custom][custom]

Last but not least, Slice's [tagged][tagged] parameters and fields allow you to update your operations and structs over
time without breaking on-the-wire compatibility.

## Flexible and extensible

You can fine-tune the API generated by the Slice compiler with Slice [attributes][attributes]. For example, in C#, you
can map a sequence to an array (the default), or to a list, or even to a hash set:

```slice
interface Translator {
    getLanguages() -> [cs::type("HashSet<string>")] sequence<string>
}
```

The `cs::type` attribute changes the mapping for values decoded by the C# generated code and returned to you. For values
you give to the generated code, the mapping for a `sequence<string>` parameter is always `IEnumerable<string>`.

Slice's custom types allow you to send any type you wish through Slice. You just need to provide methods to encode and
decode instances of your custom type.

The [well-known][well-known] types `Duration`, `TimeStamp` and `Uri` are custom types included in all IceRPC
implementations; in C#, they correspond to the System types you'd expect—`TimeSpan`, `DateTime` and `Uri`.

```slice
[cs::namespace("IceRpc.Slice")]
module WellKnownTypes

/// Represents a length of time, encoded as a varint62.
/// Precision: 100 nanoseconds.
[cs::type("System.TimeSpan")]
custom Duration
```

[attributes]: ../../slice/language-guide/attributes
[custom]: ../../slice/language-guide/custom-types
[dictionary]: ../../slice/language-guide/dictionary-types
[enum]: ../../slice/language-guide/enum-types
[exception]: ../../slice/language-guide/exception
[grpc]: https://grpc.io/
[idl]: https://en.wikipedia.org/wiki/Interface_description_language
[greeter-core]: https://github.com/icerpc/icerpc-csharp/tree/main/examples/GreeterCore
[greeter-json]: https://github.com/icerpc/icerpc-csharp/tree/main/examples/GreeterJson
[greeter-protobuf]: https://github.com/icerpc/icerpc-csharp/tree/main/examples/GreeterProtobuf
[primitive]: ../../slice/language-guide/primitive-types
[sequence]: ../../slice/language-guide/sequence-types
[slice]: ../../slice
[struct]: ../../slice/language-guide/struct-types
[tagged]: ../../slice/language-guide/parameters-and-fields#tagged-parameters-and-fields
[well-known]: ../../slice/language-guide/well-known-types
